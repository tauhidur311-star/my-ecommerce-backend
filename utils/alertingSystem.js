const nodemailer = require('nodemailer');
const logger = require('./structuredLogger');

class AlertingSystem {
  constructor() {
    this.emailTransporter = null;
    this.alertQueue = [];
    this.isProcessing = false;
    this.initializeEmailTransporter();
  }

  async initializeEmailTransporter() {
    try {
      if (process.env.SMTP_HOST && process.env.SMTP_USER && process.env.SMTP_PASS) {
        this.emailTransporter = nodemailer.createTransporter({
          host: process.env.SMTP_HOST,
          port: process.env.SMTP_PORT || 587,
          secure: false,
          auth: {
            user: process.env.SMTP_USER,
            pass: process.env.SMTP_PASS
          }
        });

        // Verify connection
        await this.emailTransporter.verify();
        logger.info('Alerting system email transporter initialized');
      } else {
        logger.warn('Email alerting not configured - missing SMTP credentials');
      }
    } catch (error) {
      logger.error('Failed to initialize email transporter', { error: error.message });
    }
  }

  async sendAlert(severity, title, message, metadata = {}) {
    const alert = {
      id: Math.random().toString(36).substring(7),
      severity,
      title,
      message,
      metadata,
      timestamp: new Date().toISOString()
    };

    // Add to queue
    this.alertQueue.push(alert);

    // Process queue if not already processing
    if (!this.isProcessing) {
      this.processAlertQueue();
    }

    // Log the alert
    logger.logSecurity(`ALERT_${severity.toUpperCase()}`, {
      alertId: alert.id,
      title,
      message,
      ...metadata
    });

    return alert.id;
  }

  async processAlertQueue() {
    if (this.isProcessing || this.alertQueue.length === 0) return;

    this.isProcessing = true;

    try {
      while (this.alertQueue.length > 0) {
        const alert = this.alertQueue.shift();
        await this.processAlert(alert);
      }
    } catch (error) {
      logger.error('Error processing alert queue', { error: error.message });
    } finally {
      this.isProcessing = false;
    }
  }

  async processAlert(alert) {
    const { severity, title, message, metadata } = alert;

    // Send email for high/critical alerts
    if ((severity === 'high' || severity === 'critical') && this.emailTransporter) {
      await this.sendEmailAlert(alert);
    }

    // Send Slack notification if configured
    if (process.env.SLACK_WEBHOOK_URL) {
      await this.sendSlackAlert(alert);
    }

    // Log to console for immediate visibility in development
    if (process.env.NODE_ENV !== 'production') {
      console.warn(`ðŸš¨ ${severity.toUpperCase()} ALERT: ${title} - ${message}`);
    }
  }

  async sendEmailAlert(alert) {
    try {
      const { severity, title, message, metadata, timestamp } = alert;
      
      const htmlContent = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <div style="background: ${this.getSeverityColor(severity)}; color: white; padding: 20px; text-align: center;">
            <h1>ðŸš¨ Security Alert - ${severity.toUpperCase()}</h1>
          </div>
          
          <div style="padding: 20px; background: #f9f9f9;">
            <h2>${title}</h2>
            <p><strong>Message:</strong> ${message}</p>
            <p><strong>Severity:</strong> ${severity}</p>
            <p><strong>Timestamp:</strong> ${timestamp}</p>
            
            ${metadata && Object.keys(metadata).length > 0 ? `
              <div style="margin-top: 20px;">
                <h3>Additional Details:</h3>
                <pre style="background: white; padding: 10px; border-radius: 5px; overflow-x: auto;">${JSON.stringify(metadata, null, 2)}</pre>
              </div>
            ` : ''}
          </div>
          
          <div style="padding: 20px; text-align: center; background: #e9e9e9; color: #666;">
            <p>This alert was generated by the E-commerce Security System</p>
            <p>Environment: ${process.env.NODE_ENV}</p>
          </div>
        </div>
      `;

      const mailOptions = {
        from: process.env.FROM_EMAIL || 'security@yourdomain.com',
        to: process.env.ALERT_EMAIL || 'admin@yourdomain.com',
        subject: `ðŸš¨ ${severity.toUpperCase()} Security Alert: ${title}`,
        html: htmlContent
      };

      await this.emailTransporter.sendMail(mailOptions);
      logger.info('Security alert email sent', { alertId: alert.id, severity, title });

    } catch (error) {
      logger.error('Failed to send alert email', { 
        error: error.message, 
        alertId: alert.id 
      });
    }
  }

  async sendSlackAlert(alert) {
    try {
      const { severity, title, message, metadata, timestamp } = alert;
      
      const payload = {
        text: `ðŸš¨ ${severity.toUpperCase()} Security Alert`,
        attachments: [
          {
            color: this.getSeverityColor(severity),
            fields: [
              {
                title: "Alert",
                value: title,
                short: false
              },
              {
                title: "Message",
                value: message,
                short: false
              },
              {
                title: "Severity",
                value: severity,
                short: true
              },
              {
                title: "Timestamp",
                value: timestamp,
                short: true
              },
              {
                title: "Environment",
                value: process.env.NODE_ENV,
                short: true
              }
            ],
            footer: "E-commerce Security System",
            ts: Math.floor(Date.now() / 1000)
          }
        ]
      };

      // Add metadata if available
      if (metadata && Object.keys(metadata).length > 0) {
        payload.attachments[0].fields.push({
          title: "Additional Details",
          value: `\`\`\`${JSON.stringify(metadata, null, 2)}\`\`\``,
          short: false
        });
      }

      const response = await fetch(process.env.SLACK_WEBHOOK_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

      if (response.ok) {
        logger.info('Slack alert sent', { alertId: alert.id, severity, title });
      } else {
        throw new Error(`Slack API responded with status ${response.status}`);
      }

    } catch (error) {
      logger.error('Failed to send Slack alert', { 
        error: error.message, 
        alertId: alert.id 
      });
    }
  }

  getSeverityColor(severity) {
    const colors = {
      low: '#36a2eb',
      medium: '#ffcd56',
      high: '#ff6384',
      critical: '#ff0000'
    };
    return colors[severity] || colors.medium;
  }

  // Security event handlers
  async handleSecurityEvent(eventType, data = {}) {
    switch (eventType) {
      case 'multiple_failed_logins':
        return this.sendAlert('high', 'Multiple Failed Login Attempts', 
          `Multiple failed login attempts detected from IP: ${data.ip}`, data);

      case 'rate_limit_exceeded':
        return this.sendAlert('medium', 'Rate Limit Exceeded', 
          `Rate limit exceeded for IP: ${data.ip} on endpoint: ${data.endpoint}`, data);

      case 'suspicious_activity':
        return this.sendAlert('high', 'Suspicious Activity Detected', 
          `Suspicious activity detected: ${data.activity}`, data);

      case 'csrf_violation':
        return this.sendAlert('high', 'CSRF Token Violation', 
          `CSRF token violation from IP: ${data.ip}`, data);

      case 'sql_injection_attempt':
        return this.sendAlert('critical', 'SQL Injection Attempt', 
          `Potential SQL injection attempt detected`, data);

      case 'xss_attempt':
        return this.sendAlert('high', 'XSS Attempt', 
          `Potential XSS attempt detected`, data);

      case 'unauthorized_admin_access':
        return this.sendAlert('critical', 'Unauthorized Admin Access', 
          `Unauthorized admin access attempt`, data);

      case 'file_upload_threat':
        return this.sendAlert('high', 'Malicious File Upload', 
          `Potentially malicious file upload detected`, data);

      case 'database_error':
        return this.sendAlert('medium', 'Database Error', 
          `Database operation failed: ${data.operation}`, data);

      case 'performance_degradation':
        return this.sendAlert('medium', 'Performance Issue', 
          `Performance degradation detected: ${data.metric}`, data);

      default:
        return this.sendAlert('medium', 'Security Event', 
          `Security event: ${eventType}`, data);
    }
  }

  // Inventory-specific alerts
  async handleInventoryAlert(alertType, data = {}) {
    switch (alertType) {
      case 'low_stock':
        return this.sendAlert('medium', 'Low Stock Alert', 
          `Product "${data.productName}" is low in stock (${data.quantity} remaining)`, data);

      case 'out_of_stock':
        return this.sendAlert('high', 'Out of Stock Alert', 
          `Product "${data.productName}" is out of stock`, data);

      case 'high_demand':
        return this.sendAlert('low', 'High Demand Alert', 
          `Product "${data.productName}" experiencing high demand`, data);

      default:
        return this.sendAlert('medium', 'Inventory Alert', 
          `Inventory alert: ${alertType}`, data);
    }
  }
}

// Export singleton instance
const alertingSystem = new AlertingSystem();
module.exports = alertingSystem;